<!doctype html>
<html lang="en">
  <head>
    <!-- Consent Mode Default -->
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("consent", "default", {
        ad_storage: "denied",
        ad_user_data: "denied",
        ad_personalization: "denied",
        analytics_storage: "denied",
      });
    </script>
    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-SPEWBEZZSN"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-SPEWBEZZSN");
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Admin Dashboard - Rahumi</title>
    <link rel="icon" href="../assets/images/profile_pictures/Rahumi.jpg" />
    <link rel="stylesheet" href="../styles/variables.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&family=Quicksand:wght@500;700&display=swap"
    />
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Nunito", "Segoe UI", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        min-height: 100vh;
      }

      .hidden {
        display: none !important;
      }

      /* ==================== LOGIN VIEW ==================== */
      #login-view {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 2rem;
      }

      .login-card {
        background: var(--surface-color);
        padding: 3rem;
        border-radius: 16px;
        box-shadow: var(--shadow-md);
        width: 100%;
        max-width: 420px;
        text-align: center;
      }

      .login-header {
        margin-bottom: 2rem;
      }

      .login-header .logo {
        font-family: "Quicksand", sans-serif;
        font-size: 2rem;
        font-weight: 700;
        color: var(--primary-dark);
        margin-bottom: 0.5rem;
      }

      .login-header p {
        color: var(--text-light);
        font-size: 0.95rem;
      }

      .form-group {
        margin-bottom: 1.25rem;
        text-align: left;
      }

      .form-group label {
        display: block;
        font-weight: 600;
        color: var(--text-color);
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
      }

      .form-group input,
      .form-group select {
        width: 100%;
        padding: 0.875rem 1rem;
        border: 2px solid var(--primary-light);
        border-radius: 10px;
        font-size: 1rem;
        font-family: inherit;
        color: var(--text-color);
        background: var(--bg-color);
        transition:
          border-color 0.2s,
          box-shadow 0.2s;
      }

      .form-group input:focus,
      .form-group select:focus,
      .form-group textarea:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(136, 192, 166, 0.2);
      }

      .form-group textarea {
        width: 100%;
        height: 300px;
        padding: 1rem;
        border: 2px solid var(--primary-light);
        border-radius: 10px;
        font-size: 1rem;
        font-family:
          "Courier New", Courier, monospace; /* Monospace for Markdown editing */
        color: var(--text-color);
        background: var(--bg-color);
        resize: vertical; /* Allow vertical resizing only */
        overflow-y: auto;
      }

      /* ==================== BUTTONS ==================== */
      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        padding: 0.875rem 1.5rem;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50px;
        font-size: 1rem;
        font-weight: 700;
        font-family: inherit;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .btn:hover:not(:disabled) {
        background-color: var(--primary-dark);
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }

      .btn:disabled {
        opacity: 0.7;
        cursor: not-allowed;
        transform: none;
      }

      .btn-secondary {
        background-color: transparent;
        color: var(--text-light);
        border: 2px solid var(--primary-light);
      }

      .btn-secondary:hover:not(:disabled) {
        background-color: var(--primary-light);
        color: var(--text-color);
      }

      .btn-full {
        width: 100%;
      }

      /* Channel Buttons */
      .channel-btn {
        background-color: var(--surface-color);
        color: var(--text-color);
        border: 2px solid var(--primary-light);
      }

      .channel-btn.active {
        background-color: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
        box-shadow: var(--shadow-md);
      }

      /* ==================== STATUS MESSAGES ==================== */
      .status-message {
        margin-top: 1.5rem;
        padding: 1rem;
        border-radius: 10px;
        font-weight: 600;
        display: none;
        text-align: center;
      }

      .status-message.show {
        display: block;
      }

      .status-message.success {
        background-color: rgba(136, 192, 166, 0.2);
        color: var(--primary-dark);
        border: 1px solid var(--primary-color);
      }

      .status-message.error {
        background-color: rgba(220, 53, 69, 0.1);
        color: #dc3545;
        border: 1px solid rgba(220, 53, 69, 0.3);
      }

      .status-message.loading {
        background-color: rgba(136, 192, 166, 0.1);
        color: var(--text-light);
        border: 1px solid var(--primary-light);
      }

      /* ==================== DASHBOARD VIEW ==================== */
      #dashboard-view {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      .dashboard-header {
        background: var(--surface-color);
        padding: 1rem 2rem;
        box-shadow: var(--shadow-sm);
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .dashboard-header h1 {
        font-family: "Quicksand", sans-serif;
        font-size: 1.5rem;
        color: var(--primary-dark);
      }

      .header-actions {
        display: flex;
        gap: 0.75rem;
      }

      .dashboard-content {
        flex: 1;
        padding: 2rem;
        max-width: 800px;
        margin: 0 auto;
        width: 100%;
      }

      /* ==================== CHANNEL SELECTOR ==================== */
      .channel-selector {
        display: flex;
        justify-content: center;
        gap: 1rem;
        margin-bottom: 2rem;
        flex-wrap: wrap;
      }

      .channel-info {
        text-align: center;
        margin-bottom: 1.5rem;
        color: var(--text-light);
      }

      /* ==================== MAP CARDS ==================== */
      .maps-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 100px;
      }

      .map-card {
        background: var(--surface-color);
        border-radius: 12px;
        padding: 1rem;
        display: flex;
        align-items: center;
        gap: 1rem;
        box-shadow: var(--shadow-sm);
        border: 1px solid #eee;
        transition:
          box-shadow 0.2s,
          transform 0.2s;
        position: relative;
      }

      .map-card:hover {
        box-shadow: var(--shadow-md);
      }

      .drag-handle {
        cursor: grab;
        font-size: 1.25rem;
        color: var(--text-light);
        padding: 0.5rem;
        user-select: none;
      }

      .drag-handle:active {
        cursor: grabbing;
      }

      .map-card-content {
        flex: 1;
        min-width: 0;
      }

      .map-card-content h3 {
        font-size: 1rem;
        font-weight: 700;
        color: var(--text-color);
        margin-bottom: 0.25rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .map-card-content .links {
        font-size: 0.8rem;
        color: var(--text-light);
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .map-card-content .links a {
        color: var(--primary-color);
        text-decoration: none;
      }

      .map-card-content .links a:hover {
        text-decoration: underline;
      }

      .delete-btn {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: #dc3545;
        color: white;
        border: 2px solid white;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s;
        box-shadow: var(--shadow-sm);
      }

      .delete-btn:hover {
        transform: scale(1.1);
        background: #c82333;
      }

      /* Drag and Drop States */
      .map-card.sortable-ghost {
        opacity: 0.4;
        background: var(--primary-light);
      }

      .map-card.sortable-chosen {
        box-shadow: 0 8px 24px rgba(136, 192, 166, 0.4);
        transform: scale(1.02);
      }

      /* ==================== MODAL ==================== */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 1rem;
      }

      .modal {
        background: var(--surface-color);
        border-radius: 16px;
        padding: 2rem;
        width: 100%;
        max-width: 480px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      .modal h2 {
        font-family: "Quicksand", sans-serif;
        color: var(--primary-dark);
        margin-bottom: 1.5rem;
        text-align: center;
      }

      .modal-actions {
        display: flex;
        gap: 1rem;
        margin-top: 1.5rem;
      }

      .modal-actions .btn {
        flex: 1;
      }

      /* ==================== SAVE BAR ==================== */
      .save-bar {
        position: sticky;
        bottom: 0;
        background: var(--surface-color);
        padding: 1rem 2rem;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
      }

      /* ==================== RESPONSIVE ==================== */
      @media (max-width: 600px) {
        .dashboard-header {
          flex-direction: column;
          gap: 1rem;
          text-align: center;
        }

        .header-actions {
          width: 100%;
          justify-content: center;
        }

        .map-card {
          flex-direction: column;
          align-items: flex-start;
        }

        .drag-handle {
          align-self: center;
        }
      }
      /* YouTuber Badge Style */
      .youtuber-badge {
        display: inline-flex;
        align-items: center;
        background-color: #e0e0e0; /* Grey box */
        padding: 2px 10px;
        border-radius: 12px;
        color: #333333; /* Dark text for contrast */
        font-weight: 700;
        font-size: 0.9em;
        margin: 0 4px;
        text-decoration: none;
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
        border: 1px solid #ccc;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      }

      .youtuber-badge:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .youtuber-badge img {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-left: 6px;
        object-fit: cover;
      }

      .youtuber-badge span {
        margin-right: 2px;
      }

      .missing-article-badge {
        background-color: #ffebee;
        color: #c62828;
        border: 1px solid #ef9a9a;
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 0.75rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        margin-left: 0.5rem;
        cursor: help;
      }

      /* Dark Mode Overrides */
      [data-theme="dark"] .status-message.loading {
        background-color: rgba(136, 192, 166, 0.05);
        border-color: #2d3b36;
      }

      [data-theme="dark"] .status-message.error {
        background-color: rgba(220, 53, 69, 0.1);
        color: #ff6b6b;
        border-color: rgba(220, 53, 69, 0.4);
      }

      [data-theme="dark"] .map-card {
        border-color: var(--border-color);
      }

      [data-theme="dark"] .missing-article-badge {
        background-color: #3a1c1c;
        border-color: #5c2b2b;
        color: #ff9999;
      }

      [data-theme="dark"] .youtuber-badge {
        background-color: #333;
        border-color: #444;
        color: #ddd;
      }

      /* ==================== AI GENERATION PROGRESS ==================== */
      .ai-progress-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.95);
        z-index: 10;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 10px;
        padding: 2rem;
      }

      [data-theme="dark"] .ai-progress-overlay {
        background: rgba(30, 30, 30, 0.95);
      }

      .ai-progress-overlay.show {
        display: flex;
      }

      .progress-steps {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: 100%;
        max-width: 300px;
      }

      .progress-step {
        display: flex;
        align-items: center;
        gap: 1rem;
        opacity: 0.5;
        transition: all 0.3s ease;
      }

      .progress-step.active {
        opacity: 1;
        transform: scale(1.02);
      }

      .progress-step.completed {
        opacity: 0.8;
      }

      .step-icon {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: var(--surface-color);
        border: 2px solid var(--text-light);
        color: var(--text-light);
        font-size: 0.8rem;
        transition: all 0.3s ease;
      }

      .progress-step.active .step-icon {
        border-color: var(--primary-color);
        color: var(--primary-color);
        animation: pulse 1.5s infinite;
      }

      .progress-step.completed .step-icon {
        background: var(--primary-color);
        border-color: var(--primary-color);
        color: white;
      }

      .step-label {
        font-weight: 600;
        color: var(--text-color);
      }

      @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(136, 192, 166, 0.4); }
        70% { box-shadow: 0 0 0 10px rgba(136, 192, 166, 0); }
        100% { box-shadow: 0 0 0 0 rgba(136, 192, 166, 0); }
      }
    </style>
    <script>
      function initTheme() {
        const saved = localStorage.getItem("theme");
        if (saved) {
          document.documentElement.setAttribute("data-theme", saved);
        } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
          document.documentElement.setAttribute("data-theme", "dark");
        }
      }
      initTheme();

      function toggleTheme() {
        const current = document.documentElement.getAttribute("data-theme");
        const target = current === "dark" ? "light" : "dark";
        document.documentElement.setAttribute("data-theme", target);
        localStorage.setItem("theme", target);
        updateThemeIcons(target);
      }

      function updateThemeIcons(theme) {
        // We will add class 'theme-icon' to the icons
        const icons = document.querySelectorAll(".theme-icon");
        icons.forEach((icon) => {
          icon.className =
            theme === "dark"
              ? "fas fa-sun theme-icon"
              : "fas fa-moon theme-icon";
        });
      }

      document.addEventListener("DOMContentLoaded", () => {
        const current =
          document.documentElement.getAttribute("data-theme") || "light";
        updateThemeIcons(current);
      });
    </script>
  </head>
  <body>
    <!-- ==================== LOGIN VIEW ==================== -->
    <div id="login-view">
      <div class="login-card" style="position: relative">
        <button
          onclick="toggleTheme()"
          class="btn btn-secondary"
          style="
            position: absolute;
            top: 1rem;
            right: 1rem;
            padding: 0.5rem;
            border: none;
            background: transparent;
            color: var(--text-color);
          "
        >
          <i class="fas fa-moon theme-icon"></i>
        </button>
        <div class="login-header">
          <div class="logo">üîê Admin Panel</div>
          <p>Authorized access only</p>
        </div>
        <form id="login-form">
          <div class="form-group">
            <label for="email">Email Address</label>
            <input
              type="email"
              id="email"
              required
              placeholder="admin@example.com"
              autocomplete="email"
            />
          </div>
          <div class="form-group">
            <label for="password">Password</label>
            <input
              type="password"
              id="password"
              required
              placeholder="Enter your password"
              autocomplete="current-password"
            />
          </div>
          <button type="submit" class="btn btn-full" id="login-btn">
            Sign In
          </button>
        </form>
        <div id="login-status" class="status-message"></div>
      </div>
    </div>

    <!-- ==================== DASHBOARD VIEW ==================== -->
    <div id="dashboard-view" class="hidden">
      <header class="dashboard-header">
        <h1>üéÆ Content Dashboard</h1>
        <div class="header-actions">
          <button
            onclick="toggleTheme()"
            class="btn btn-secondary"
            style="padding: 0.5rem 1rem"
          >
            <i class="fas fa-moon theme-icon"></i>
          </button>
          <button id="add-item-btn" class="btn">‚ûï Add Item</button>
          <button id="logout-btn" class="btn btn-secondary">Sign Out</button>
        </div>
      </header>

      <main class="dashboard-content">
        <!-- Status -->
        <div id="loading-indicator" class="status-message show loading">
          Loading content...
        </div>

        <!-- Channel Selector Buttons -->
        <div id="channel-buttons" class="channel-selector"></div>

        <!-- Channel Info -->
        <div id="channel-info" class="channel-info"></div>

        <!-- Maps List for Current Channel -->
        <div id="maps-list" class="maps-list"></div>
      </main>

      <footer class="save-bar">
        <button id="save-btn" class="btn" disabled>üíæ Save Changes</button>
        <div
          id="save-status"
          class="status-message"
          style="margin: 0; padding: 0.5rem 1rem"
        ></div>
      </footer>
    </div>

    <!-- ==================== ADD ITEM MODAL ==================== -->
    <div id="add-modal" class="modal-overlay hidden">
      <div class="modal">
        <h2>‚ûï Add New Item</h2>
        <form id="add-form">
          <!-- Map Name Removed -->
          <div class="form-group">
            <label for="add-video-link">Video Link</label>
            <input
              type="url"
              id="add-video-link"
              required
              placeholder="https://youtu.be/..."
            />
          </div>
          <div class="form-group">
            <label for="add-map-link">Map Link (Roblox)</label>
            <input
              type="url"
              id="add-map-link"
              required
              placeholder="https://www.roblox.com/games/..."
            />
          </div>
          <div class="form-group">
            <label for="add-article-content">
              Article Content (Markdown)
              <button
                type="button"
                id="generate-article-btn"
                class="btn"
                style="
                  margin-left: 10px;
                  font-size: 0.8em;
                  padding: 4px 12px;
                  background-color: #7b1fa2;
                "
              >
                ‚ú® Generate with AI
              </button>
            </label>
            <div style="position: relative;">
                <textarea id="add-article-content"></textarea>
                <!-- Progress Overlay -->
                <div id="ai-progress" class="ai-progress-overlay">
                    <h3 style="margin-bottom: 1.5rem; color: var(--primary-dark);">Creation in Progress...</h3>
                    <div id="realtime-logs" style="
                        width: 100%;
                        max-width: 400px;
                        max-height: 250px;
                        overflow-y: auto;
                        background: rgba(0,0,0,0.05);
                        border-radius: 8px;
                        padding: 1rem;
                        font-family: monospace;
                        font-size: 0.9rem;
                    ">
                        <div class="log-entry" style="color: var(--text-color); margin-bottom: 0.5rem; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 0.5rem;">
                            <i class="fas fa-satellite-dish"></i> Connecting to AI...
                        </div>
                    </div>
                    <p id="progress-timer" style="margin-top: 1.5rem; color: var(--text-light); font-size: 0.9rem; font-family: monospace;">00:00</p>
                    <button id="ai-progress-close-btn" class="btn" style="margin-top: 1rem; display: none;">Close</button>
                </div>
            </div>
          </div>
          <div class="modal-actions">
            <button type="button" id="cancel-add-btn" class="btn btn-secondary">
              Cancel
            </button>
            <button type="submit" class="btn">Add Item</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import {
        getAuth,
        signInWithEmailAndPassword,
        signOut,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        onSnapshot,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
      import {
        getFunctions,
        httpsCallable,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js";

      // Import Config
      import { firebaseConfig } from "../config/firebase-config.js";

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);
      const functions = getFunctions(app);

      // ==================== STATE ====================
      let allChannelsData = {}; // All channels: { "channelName": [...maps], ... }
      let channelOrder = []; // Preserves original channel order
      let currentChannel = null;
      let hasChanges = false;
      let sortableInstance = null;
      let editingItemCard = null; // Track which card is being edited (null = adding new)

      // ==================== DOM ELEMENTS ====================
      const loginView = document.getElementById("login-view");
      const dashboardView = document.getElementById("dashboard-view");
      const loginForm = document.getElementById("login-form");
      const loginBtn = document.getElementById("login-btn");
      const logoutBtn = document.getElementById("logout-btn");
      const loginStatus = document.getElementById("login-status");
      const loadingIndicator = document.getElementById("loading-indicator");
      const channelButtonsContainer =
        document.getElementById("channel-buttons");
      const channelInfo = document.getElementById("channel-info");
      const mapsList = document.getElementById("maps-list");
      const addItemBtn = document.getElementById("add-item-btn");
      const addModal = document.getElementById("add-modal");
      const addForm = document.getElementById("add-form");
      const cancelAddBtn = document.getElementById("cancel-add-btn");
      const saveBtn = document.getElementById("save-btn");
      const saveStatus = document.getElementById("save-status");

      // ==================== AUTH STATE ====================
      onAuthStateChanged(auth, async (user) => {
        if (user) {
          loginView.classList.add("hidden");
          dashboardView.classList.remove("hidden");
          await loadContent();
        } else {
          loginView.classList.remove("hidden");
          dashboardView.classList.add("hidden");
        }
      });

      // ==================== LOGIN ====================
      loginForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const email = document.getElementById("email").value;
        const password = document.getElementById("password").value;

        loginBtn.disabled = true;
        loginBtn.textContent = "Signing in...";
        showStatus(loginStatus, "Authenticating...", "loading");

        try {
          await signInWithEmailAndPassword(auth, email, password);
        } catch (error) {
          showStatus(loginStatus, getErrorMessage(error.code), "error");
        } finally {
          loginBtn.disabled = false;
          loginBtn.textContent = "Sign In";
        }
      });

      // ==================== LOGOUT ====================
      logoutBtn.addEventListener("click", async () => {
        if (
          hasChanges &&
          !confirm(
            "You have unsaved changes. Are you sure you want to sign out?",
          )
        ) {
          return;
        }
        await signOut(auth);
      });

      // ==================== HELPER: RETRY LOGIC ====================
      async function getDocWithRetry(docRef, retries = 3, delay = 1000) {
        try {
          return await getDoc(docRef);
        } catch (error) {
          // Check for offline/connection errors
          const isOffline =
            error.message.includes("offline") ||
            error.code === "unavailable" ||
            error.message.includes("network");

          if (retries > 0 && isOffline) {
            console.warn(
              `Firestore getDoc failed. Retrying in ${delay}ms...`,
              error,
            );

            // Optional: Update loading text
            if (
              loadingIndicator &&
              !loadingIndicator.classList.contains("hidden")
            ) {
              loadingIndicator.textContent = `Connection unstable. Retrying... (${retries} attempts left)`;
            }

            await new Promise((resolve) => setTimeout(resolve, delay));
            return getDocWithRetry(docRef, retries - 1, delay * 1.5); // Backoff
          }
          throw error;
        }
      }

      // ==================== LOAD CONTENT ====================
      async function loadContent() {
        loadingIndicator.classList.remove("hidden");
        loadingIndicator.textContent = "Loading content...";

        try {
          // Try Firestore first
          const docRef = doc(db, "content", "main");
          const docSnap = await getDocWithRetry(docRef);

          if (docSnap.exists() && docSnap.data().maps) {
            const data = docSnap.data();
            allChannelsData = data.maps;
            // Sort channels by list_number
            channelOrder = Object.keys(allChannelsData).sort((a, b) => {
              return (allChannelsData[a].list_number ?? 999) - (allChannelsData[b].list_number ?? 999);
            });
            console.log("Loaded from Firestore:", channelOrder);
          } else {
            // Fallback: Load from local links.json
            loadingIndicator.textContent = "Loading from local JSON...";
            const response = await fetch(
              "../config/links.json?t=" + new Date().getTime(),
            );
            if (!response.ok) throw new Error("Failed to load links.json");
            allChannelsData = await response.json();
            // Sort channels by list_number
            channelOrder = Object.keys(allChannelsData).sort((a, b) => {
              return (allChannelsData[a].list_number ?? 999) - (allChannelsData[b].list_number ?? 999);
            });
            console.log("Loaded from links.json:", channelOrder);
          }

          // Render channel buttons
          renderChannelButtons();

          // Select first channel by default
          if (channelOrder.length > 0) {
            switchChannel(channelOrder[0]);
          }

          loadingIndicator.classList.add("hidden");
        } catch (error) {
          console.error("Error loading content:", error);
          loadingIndicator.textContent =
            "Error loading content: " + error.message;
          loadingIndicator.className = "status-message show error";
        }
      }

      // ==================== RENDER CHANNEL BUTTONS ====================
      function renderChannelButtons() {
        channelButtonsContainer.innerHTML = "";

        // Use channelOrder to ensure consistent button order
        channelOrder.forEach((channelName) => {
          if (allChannelsData[channelName]) {
            const btn = document.createElement("button");
            btn.className = "btn channel-btn";
            btn.textContent = channelName;
            btn.dataset.channel = channelName;
            btn.onclick = () => switchChannel(channelName);
            channelButtonsContainer.appendChild(btn);
          }
        });
      }

      // ==================== TEXT DIRECTION HELPER ====================
      function setElementDirection(element, text) {
        const arabicPattern =
          /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
        if (arabicPattern.test(text)) {
          element.style.direction = "rtl";
          element.style.textAlign = "right";
        } else {
          element.style.direction = "ltr";
          element.style.textAlign = "left";
        }
      }

      function updateChannelButtonStyles() {
        const buttons =
          channelButtonsContainer.querySelectorAll(".channel-btn");
        buttons.forEach((btn) => {
          if (btn.dataset.channel === currentChannel) {
            btn.classList.add("active");
          } else {
            btn.classList.remove("active");
          }
        });
      }

      function normalizeYoutubeLink(url) {
        if (!url) return "";
        const match = url.match(
          /^.*(youtu.be\/|v\/|u\/\w\/|embed\/|watch\?v=|&v=)([^#&?]*).*/,
        );
        if (match && match[2].length === 11) {
          return `https://youtu.be/${match[2]}`;
        }
        return url;
      }

      // ==================== SWITCH CHANNEL ====================
      function switchChannel(channelName) {
        currentChannel = channelName;
        updateChannelButtonStyles();
        renderMapsList();
      }

      // ==================== TITLE FORMATTING HELPERS ====================
      const channelDataCache = {};
      const channelFetchPromises = {};

      async function fetchChannelInfo(handle) {
        if (channelDataCache[handle]) return channelDataCache[handle];
        if (channelFetchPromises[handle]) return channelFetchPromises[handle];

        const fetchPromise = (async () => {
          const channelUrl = `https://www.youtube.com/@${handle}`;
          try {
            const response = await fetch(
              `https://api.microlink.io/?url=${encodeURIComponent(channelUrl)}`,
            );
            if (!response.ok) throw new Error("Microlink fetch failed");

            const json = await response.json();
            if (json.status === "success" && json.data) {
              const info = {
                name: json.data.author || json.data.title || handle,
                url: json.data.url || channelUrl,
                image: json.data.image ? json.data.image.url : null,
                logo: json.data.logo ? json.data.logo.url : null,
              };
              info.avatar =
                info.image ||
                info.logo ||
                `https://unavatar.io/youtube/@${handle}`;
              channelDataCache[handle] = info;
              return info;
            }
          } catch (error) {
            console.warn("Error fetching channel info for", handle, error);
          }

          const fallbackInfo = {
            name: handle,
            url: channelUrl,
            avatar: `https://unavatar.io/youtube/@${handle}`,
          };
          channelDataCache[handle] = fallbackInfo;
          return fallbackInfo;
        })();

        channelFetchPromises[handle] = fetchPromise;
        return fetchPromise;
      }

      function formatTitleWithBadges(title) {
        if (!title) return "";

        // Clean up phrases
        let cleaned = title
          .replace(/ÿ±Ÿàÿ®ŸàŸÑŸÉÿ≥ : /g, "")
          .replace(/ÿ±Ÿàÿ®ŸÑŸàŸÉÿ≥ : ŸàŸÑŸÉŸÜ /g, "")
          .replace(/ÿ±Ÿàÿ®ŸÑŸàŸÉÿ≥ : /g, "")
          .replace(/ÿ±Ÿàÿ®ŸÑŸàŸÉÿ≥: /g, "")
          .replace(/ÿ±Ÿàÿ®ŸÑŸàŸÉÿ≥ ŸàŸÑŸÉŸÜ /g, "")
          .replace(/ÿ±Ÿàÿ®ŸÑŸàŸÉÿ≥ /g, "")
          .replace(/ ŸÅŸä ŸÑÿπÿ®ÿ© ÿ±Ÿàÿ®ŸÑŸàŸÉÿ≥/g, "")
          .replace(/ ŸÅŸä ÿ±Ÿàÿ®ŸÑŸàŸÉÿ≥/g, "");

        cleaned = cleaned
          .trim()
          .replace(/^[:\s-]+/g, "")
          .trim();

        // Regex to find @Handle
        const regex = /@([a-zA-Z0-9_.-]+)/g;

        return cleaned.replace(regex, (match, handle) => {
          return `<a href="https://www.youtube.com/@${handle}" target="_blank" class="youtuber-badge pending-badge" data-handle="${handle}" onclick="event.stopPropagation();">
                    <i class="fab fa-youtube" style="margin-left:5px; color: #ff0000;"></i>
                    <span>${handle}</span>
                </a>`;
        });
      }

      async function processBadges(container) {
        const badges = container.querySelectorAll(
          ".youtuber-badge.pending-badge",
        );

        for (const badge of badges) {
          const handle = badge.dataset.handle;
          badge.classList.remove("pending-badge");

          // Fetch dynamic data
          fetchChannelInfo(handle).then((info) => {
            updateBadgeUI(badge, info.name, info.avatar, info.url);
          });
        }
      }

      function updateBadgeUI(badge, name, avatar, url) {
        badge.href = url;
        let content = "";
        if (avatar) {
          content += `<img src="${avatar}" alt="${name}" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline-block';" />`;
          content += `<i class="fab fa-youtube fallback-icon" style="display:none; margin-left:5px; color: #ff0000;"></i>`;
        } else {
          content += `<i class="fab fa-youtube" style="margin-left:5px; color: #ff0000;"></i>`;
        }
        content += `<span>${name}</span>`;
        badge.innerHTML = content;
      }

      // ==================== HELPER: FETCH TITLE ====================
      async function fetchVideoTitle(videoUrl) {
        if (!videoUrl) return null;
        try {
          const response = await fetch(
            `https://noembed.com/embed?url=${encodeURIComponent(videoUrl)}`,
          );
          const data = await response.json();
          return data.title;
        } catch {
          return null;
        }
      }

      // ==================== RENDER MAPS LIST ====================
      function renderMapsList() {
        mapsList.innerHTML = "";

        // Access the links array from the new structure
        const channelData = allChannelsData[currentChannel];
        const maps = channelData?.links || channelData || [];
        channelInfo.textContent = `${currentChannel} ‚Äî ${maps.length} items`;

        if (maps.length === 0) {
          mapsList.innerHTML =
            '<p style="text-align: center; color: var(--text-light); padding: 2rem;">No items in this channel. Click "Add Item" to create one.</p>';
          return;
        }

        maps.forEach((map, index) => {
          mapsList.appendChild(createMapCard(map, index));
        });

        // Initialize SortableJS
        if (sortableInstance) {
          sortableInstance.destroy();
        }
        sortableInstance = new Sortable(mapsList, {
          animation: 150,
          ghostClass: "sortable-ghost",
          chosenClass: "sortable-chosen",
          handle: ".drag-handle",
          onEnd: () => {
            updateDataFromDOM();
            markChanged();
          },
        });
      }

      function createMapCard(map, index) {
        const card = document.createElement("div");
        card.className = "map-card";
        card.dataset.index = index;

        card.innerHTML = `
                <div class="drag-handle">‚ò∞</div>
                <div class="map-card-content">
                    <h3 class="editable-title" title="Click to edit">Loading title...</h3>
                    <div class="links">
                        <a href="${escapeHtml(map.video_link)}" target="_blank">üìπ Video</a>
                        <a href="${escapeHtml(map.map_link)}" target="_blank">üéÆ Roblox</a>
                    </div>
                </div>
                <button class="delete-btn" title="Delete">‚úï</button>
            `;

        // Store full data on the card for retrieval
        card.dataset.mapData = JSON.stringify(map);

        // Fetch Title
        fetchVideoTitle(map.video_link).then((title) => {
          const titleEl = card.querySelector("h3");
          const displayTitle = title || "Loading...";

          // Apply RTL if Arabic found
          setElementDirection(titleEl, displayTitle);

          titleEl.innerHTML = formatTitleWithBadges(displayTitle);
          processBadges(titleEl);
        });

        // Check if article exists
        if (map.video_link) {
          const videoId = extractVideoId(map.video_link);
          if (videoId) {
            // Check if map object already has content (from DOM update)
            if (!map.article_content) {
              checkArticleExists(videoId).then((exists) => {
                if (!exists) {
                  const linksContainer = card.querySelector(".links");
                  const badge = document.createElement("span");
                  badge.className = "missing-article-badge";
                  badge.textContent = "‚ö†Ô∏è Article Missing!";
                  badge.title = "No Markdown file found for this video.";
                  linksContainer.appendChild(badge);
                }
              });
            }
          }
        }

        // Edit handler (Click on content area, ignore links/buttons)
        card
          .querySelector(".map-card-content")
          .addEventListener("click", (e) => {
            if (e.target.tagName === "A") return;
            openEditModal(card, map);
          });

        // Delete handler
        card.querySelector(".delete-btn").addEventListener("click", (e) => {
          e.stopPropagation();
          if (confirm("Are you sure you want to delete this item?")) {
            card.remove();
            updateDataFromDOM();
            markChanged();
            const count = mapsList.querySelectorAll(".map-card").length;
            channelInfo.textContent = `${currentChannel} ‚Äî ${count} items`;
          }
        });

        return card;
      }

      // ==================== ADD / EDIT ITEM ====================
      function openEditModal(card, mapData) {
        editingItemCard = card;

        // Update Modal Title
        addModal.querySelector("h2").textContent = card
          ? "‚úé Edit Item"
          : "‚ûï Add New Item";
        addModal.querySelector('button[type="submit"]').textContent = card
          ? "Save Changes"
          : "Add Item";

        // Fill form
        if (mapData) {
          document.getElementById("add-video-link").value =
            mapData.video_link || "";
          document.getElementById("add-map-link").value =
            mapData.map_link || "";
        } else {
          addForm.reset();
        }

        addModal.classList.remove("hidden");

        // Populate textarea: try existing data first, then fetch file
        const textarea = document.getElementById("add-article-content");
        textarea.value = mapData ? mapData.article_content || "" : "";
        textarea.placeholder = "Loading existing article...";

        if (mapData && mapData.video_link && !textarea.value) {
          const videoId = extractVideoId(mapData.video_link);
          if (videoId) {
            fetch(`../assets/articles/${videoId}.md?t=${new Date().getTime()}`)
              .then((response) => {
                if (response.ok) return response.text();
                throw new Error("Not found");
              })
              .then((text) => {
                // Only update if user hasn't started typing
                if (textarea.value === "") {
                  textarea.value = text;
                }
              })
              .catch((err) => {
                textarea.placeholder =
                  "No existing article found. Write one here...";
              });
          }
        } else if (!mapData) {
          textarea.placeholder = "Write your article here...";
        }
      }

      function extractVideoId(url) {
        if (!url) return null;
        const match = url.match(
          /(?:youtu\.be\/|youtube\.com\/watch\?v=)([^&]+)/,
        );
        return match ? match[1] : null;
      }

      addItemBtn.addEventListener("click", () => {
        openEditModal(null, null);
      });

      cancelAddBtn.addEventListener("click", () => {
        addModal.classList.add("hidden");
      });

      /*
        addModal.addEventListener('click', (e) => {
            if (e.target === addModal) {
                addModal.classList.add('hidden');
            }
        });
        */

      addForm.addEventListener("submit", (e) => {
        e.preventDefault();

        let videoLink = document.getElementById("add-video-link").value;
        videoLink = normalizeYoutubeLink(videoLink);

        const mapLink = document.getElementById("add-map-link").value;

        const newMap = {
          video_link: videoLink,
          map_link: mapLink,
          article_content: document.getElementById("add-article-content").value,
        };

        if (editingItemCard) {
          // EDIT MODE: Update existing card
          const newCard = createMapCard(newMap, 0); // index doesn't matter here
          mapsList.replaceChild(newCard, editingItemCard);
        } else {
          // ADD MODE: Add to beginning
          const newCard = createMapCard(newMap, 0);
          mapsList.prepend(newCard);
        }

        updateDataFromDOM();
        markChanged();

        // Update channel info count
        const count = mapsList.querySelectorAll(".map-card").length;
        channelInfo.textContent = `${currentChannel} ‚Äî ${count} items`;

        addModal.classList.add("hidden");
      });

      // ==================== SAVE CHANGES ====================
      saveBtn.addEventListener("click", async () => {
        // Re-verify auth
        const user = auth.currentUser;
        if (!user) {
          showStatus(
            saveStatus,
            "Not authenticated. Please sign in again.",
            "error",
          );
          return;
        }

        saveBtn.disabled = true;
        saveBtn.textContent = "‚è≥ Saving...";
        showStatus(saveStatus, "Saving to Firestore...", "loading");

        try {
          // Get existing Firestore data or create new
          const docRef = doc(db, "content", "main");
          const docSnap = await getDoc(docRef);
          let fullData = docSnap.exists() ? docSnap.data() : {};

          // Update maps and channel order
          // Update maps
          fullData.maps = allChannelsData;
          // fullData.channelOrder = channelOrder; // Removed to fix ordering issues

          // Save to Firestore
          await setDoc(docRef, fullData);

          showStatus(saveStatus, "Triggering site update...", "loading");

          // Trigger GitHub Action
          await triggerGitHubAction();

          showStatus(saveStatus, "‚úÖ Saved and published!", "success");
          hasChanges = false;
          saveBtn.disabled = true;
        } catch (error) {
          console.error("Save error:", error);
          showStatus(saveStatus, "Error: " + error.message, "error");
        } finally {
          saveBtn.textContent = "üíæ Save Changes";
        }
      });

      async function checkArticleExists(videoId) {
        try {
          // Use HEAD request to check availability efficiently
          const response = await fetch(`../assets/articles/${videoId}.md`, {
            method: "HEAD",
          });
          return response.ok;
        } catch (e) {
          return false;
        }
      }

      async function triggerGitHubAction() {
        try {
          const triggerAction = httpsCallable(functions, "triggerGitHubAction");
          const result = await triggerAction();
          console.log("GitHub Action triggered successfully:", result.data);
        } catch (error) {
          console.error("Error triggering GitHub Action:", error);
          throw new Error("Failed to trigger build: " + error.message);
        }
      }

      // ==================== AI GENERATION ====================
      const generateArticleBtn = document.getElementById(
        "generate-article-btn",
      );
      const aiProgress = document.getElementById("ai-progress");
      const progressTimer = document.getElementById("progress-timer");
      const realtimeLogs = document.getElementById("realtime-logs");

      const aiProgressCloseBtn = document.getElementById("ai-progress-close-btn");

      // Close button handler
      aiProgressCloseBtn.addEventListener("click", () => {
          aiProgress.classList.remove('show');
          generateArticleBtn.disabled = false;
          generateArticleBtn.innerHTML = generateArticleBtn.dataset.originalText || "‚ú® Generate with AI"; // Fallback text
      });

      // Generate UUID helper
      function uuidv4() {
          return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, c =>
            (+c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)
          );
      }

      generateArticleBtn.addEventListener("click", async () => {
        const videoUrl = document.getElementById("add-video-link").value;
        const textarea = document.getElementById("add-article-content");

        if (!videoUrl) {
          alert("Please enter a Video Link first.");
          return;
        }

        if (
          textarea.value &&
          !confirm(
            "This will overwrite the current content. Do you want to continue?",
          )
        ) {
          return;
        }

        const originalText = generateArticleBtn.innerHTML;
        generateArticleBtn.dataset.originalText = originalText; // Store for restore
        generateArticleBtn.disabled = true;
        
        // Setup Real-time Logging
        const requestId = uuidv4();
        aiProgress.classList.add('show');
        aiProgressCloseBtn.style.display = 'none'; // Hide close button initially
        realtimeLogs.innerHTML = `<div class="log-entry" style="color: var(--text-color); margin-bottom: 0.5rem; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 0.5rem;">
                            <i class="fas fa-satellite-dish"></i> Initializing request...
                        </div>`;

        // Start Timer
        let startTime = Date.now();
        let timerInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const secs = (elapsed % 60).toString().padStart(2, '0');
            progressTimer.textContent = `${mins}:${secs}`;
        }, 1000);

        // Listen to Firestore
        let unsubscribe;
        try {
            console.log("Subscribing to logs for requestId:", requestId);
            unsubscribe = onSnapshot(doc(db, "generation_logs", requestId), (docC) => {
                // console.log("Snapshot update:", docC.exists(), docC.data()); 
                if (docC.exists()) {
                    const data = docC.data();
                    const icon = data.type === 'error' ? 'fa-exclamation-circle' : (data.type === 'success' ? 'fa-check-circle' : 'fa-info-circle');
                    const color = data.type === 'error' ? 'red' : (data.type === 'success' ? 'green' : 'var(--text-color)');
                    
                    const logEntry = document.createElement('div');
                    logEntry.style.color = color;
                    logEntry.style.marginBottom = '0.5rem';
                    logEntry.style.paddingBottom = '0.5rem';
                    logEntry.style.borderBottom = '1px solid rgba(0,0,0,0.1)';
                    logEntry.innerHTML = `<i class="fas ${icon}"></i> ${data.message}`;
                    realtimeLogs.appendChild(logEntry);
                    // Scroll to bottom
                    realtimeLogs.scrollTop = realtimeLogs.scrollHeight;
                }
            }, (error) => {
                console.error("Snapshot listener error:", error);
                const logEntry = document.createElement('div');
                logEntry.style.color = 'red';
                logEntry.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Log connection failed: ${error.message}`;
                realtimeLogs.appendChild(logEntry);
            });
        } catch (e) {
            console.error("Failed to subscribe to logs:", e);
        }

        let isSuccess = false;

        try {
          const generate = httpsCallable(functions, "generateArticle", {
            timeout: 1200000,
          });
          const result = await generate({ videoUrl: videoUrl, requestId: requestId });

          if (result.data.success && result.data.article) {
            textarea.value = result.data.article;
            markChanged(); // Mark as modified so user can save
            isSuccess = true;
          } else {
            throw new Error("No article returned.");
          }
        } catch (error) {
          console.error("Generation failed:", error);
          // Don't alert, just log to the visible log area
          const logEntry = document.createElement('div');
          logEntry.style.color = 'red';
          logEntry.style.fontWeight = 'bold';
          logEntry.innerHTML = `<i class="fas fa-times-circle"></i> Error: ${error.message}`;
          realtimeLogs.appendChild(logEntry);
          realtimeLogs.scrollTop = realtimeLogs.scrollHeight;
        } finally {
          clearInterval(timerInterval);
          if (unsubscribe) unsubscribe(); // Stop listening
          
          if (isSuccess) {
              // On success, close automatically
              aiProgress.classList.remove('show');
              generateArticleBtn.disabled = false;
              generateArticleBtn.innerHTML = originalText;
          } else {
              // On failure, keep open and show close button
              aiProgressCloseBtn.style.display = 'inline-block';
              // Button is still disabled until they close the dialog
          }
        }
      });

      async function getGitHubToken() {
        // 1. Check LocalStorage
        let token = localStorage.getItem("github_pat");
        if (token) return token;

        // 2. Prompt User (Securely)
        const input = prompt(
          "Please enter your GitHub Personal Access Token (PAT) to publish changes.\n\nThis will be saved in your browser locally.\nThe token needs 'actions:write' or 'workflow' permissions.",
        );

        if (input && input.trim().length > 0) {
          token = input.trim();
          localStorage.setItem("github_pat", token);
          return token;
        }

        return null;
      }

      // ==================== UTILITY FUNCTIONS ====================
      function updateDataFromDOM() {
        // Rebuild current channel's data from DOM order
        const newMaps = [];
        mapsList.querySelectorAll(".map-card").forEach((card) => {
          const content = card.querySelector(".map-card-content");
          const links = content.querySelectorAll(".links a");

          // Retrieve stored data attached to the card
          const existingData = card.dataset.mapData
            ? JSON.parse(card.dataset.mapData)
            : {};

          newMaps.push({
            video_link: links[0].href,
            map_link: links[1].href,
            article_content: existingData.article_content || "",
          });
        });

        allChannelsData[currentChannel] = newMaps;
      }

      function markChanged() {
        hasChanges = true;
        saveBtn.disabled = false;
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text || "";
        return div.innerHTML;
      }

      function showStatus(element, message, type) {
        element.textContent = message;
        element.className = `status-message show ${type}`;
      }

      function getErrorMessage(errorCode) {
        const messages = {
          "auth/invalid-email": "Invalid email address format.",
          "auth/user-disabled": "This account has been disabled.",
          "auth/user-not-found": "No account found with this email.",
          "auth/wrong-password": "Incorrect password.",
          "auth/invalid-credential": "Invalid login credentials.",
          "auth/too-many-requests": "Too many failed attempts. Try later.",
        };
        return messages[errorCode] || "An unexpected error occurred.";
      }

      // Warn before leaving with unsaved changes
      window.addEventListener("beforeunload", (e) => {
        if (hasChanges) {
          e.preventDefault();
          e.returnValue = "";
        }
      });
    </script>
    <script src="../scripts/consent.js"></script>
  </body>
</html>
