<!doctype html>
<html lang="ar" dir="rtl">
  <head>
    <!-- Consent Mode Default -->
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("consent", "default", {
        ad_storage: "denied",
        ad_user_data: "denied",
        ad_personalization: "denied",
        analytics_storage: "denied",
      });
    </script>
    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-SPEWBEZZSN"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-SPEWBEZZSN");
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Admin Dashboard - Rahumi</title>
    <link rel="icon" href="../assets/images/profile_pictures/Rahumi.jpg" />
    <link rel="stylesheet" href="../styles/variables.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&family=Quicksand:wght@500;700&display=swap"
    />
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Nunito", "Segoe UI", sans-serif;
        background-color: var(--bg-color);
        color: var(--text-color);
        min-height: 100vh;
      }

      .hidden {
        display: none !important;
      }

      /* ==================== LOGIN VIEW ==================== */
      #login-view {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        padding: 2rem;
      }

      .login-card {
        background: var(--surface-color);
        padding: 3rem;
        border-radius: 16px;
        box-shadow: var(--shadow-md);
        width: 100%;
        max-width: 420px;
        text-align: center;
      }

      .login-header {
        margin-bottom: 2rem;
      }

      .login-header .logo {
        font-family: "Quicksand", sans-serif;
        font-size: 2rem;
        font-weight: 700;
        color: var(--primary-dark);
        margin-bottom: 0.5rem;
      }

      .login-header p {
        color: var(--text-light);
        font-size: 0.95rem;
      }

      .form-group {
        margin-bottom: 1.25rem;
      }

      .form-group label {
        display: block;
        font-weight: 600;
        color: var(--text-color);
        margin-bottom: 0.5rem;
        font-size: 0.9rem;
      }

      .form-group input,
      .form-group select {
        width: 100%;
        padding: 0.875rem 1rem;
        border: 2px solid var(--primary-light);
        border-radius: 10px;
        font-size: 1rem;
        font-family: inherit;
        color: var(--text-color);
        background: var(--bg-color);
        transition:
          border-color 0.2s,
          box-shadow 0.2s;
      }

      .form-group input:focus,
      .form-group select:focus,
      .form-group textarea:focus {
        outline: none;
        border-color: var(--primary-color);
        box-shadow: 0 0 0 3px rgba(136, 192, 166, 0.2);
      }

      .form-group textarea {
        width: 100%;
        height: 300px;
        padding: 1rem;
        border: 2px solid var(--primary-light);
        border-radius: 10px;
        font-size: 1rem;
        font-family:
          "Courier New", Courier, monospace; /* Monospace for Markdown editing */
        color: var(--text-color);
        background: var(--bg-color);
        resize: vertical; /* Allow vertical resizing only */
        overflow-y: auto;
      }

      /* ==================== BUTTONS ==================== */
      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        padding: 0.875rem 1.5rem;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 50px;
        font-size: 1rem;
        font-weight: 700;
        font-family: inherit;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .btn:hover:not(:disabled) {
        background-color: var(--primary-dark);
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
      }

      .btn:disabled {
        opacity: 0.7;
        cursor: not-allowed;
        transform: none;
      }

      .btn-secondary {
        background-color: transparent;
        color: var(--text-light);
        border: 2px solid var(--primary-light);
      }

      .btn-secondary:hover:not(:disabled) {
        background-color: var(--primary-light);
        color: var(--text-color);
      }

      .btn-full {
        width: 100%;
      }

      /* Channel Buttons */
      .channel-btn {
        background-color: var(--surface-color);
        color: var(--text-color);
        border: 2px solid var(--primary-light);
      }

      .channel-btn.active {
        background-color: var(--primary-color);
        color: white;
        border-color: var(--primary-color);
        box-shadow: var(--shadow-md);
      }

      /* ==================== STATUS MESSAGES ==================== */
      .status-message {
        margin-top: 1.5rem;
        padding: 1rem;
        border-radius: 10px;
        font-weight: 600;
        display: none;
        text-align: center;
      }

      .status-message.show {
        display: block;
      }

      .status-message.success {
        background-color: rgba(136, 192, 166, 0.2);
        color: var(--primary-dark);
        border: 1px solid var(--primary-color);
      }

      .status-message.error {
        background-color: rgba(220, 53, 69, 0.1);
        color: #dc3545;
        border: 1px solid rgba(220, 53, 69, 0.3);
      }

      .status-message.loading {
        background-color: rgba(136, 192, 166, 0.1);
        color: var(--text-light);
        border: 1px solid var(--primary-light);
      }

      /* ==================== DASHBOARD VIEW ==================== */
      #dashboard-view {
        display: flex;
        flex-direction: column;
        min-height: 100vh;
      }

      .dashboard-header {
        background: var(--surface-color);
        padding: 1rem 2rem;
        box-shadow: var(--shadow-sm);
        display: flex;
        justify-content: space-between;
        align-items: center;
        position: sticky;
        top: 0;
        z-index: 100;
      }

      .dashboard-header h1 {
        font-family: "Quicksand", sans-serif;
        font-size: 1.5rem;
        color: var(--primary-dark);
      }

      .header-actions {
        display: flex;
        gap: 0.75rem;
      }

      .dashboard-content {
        flex: 1;
        padding: 2rem;
        max-width: 800px;
        margin: 0 auto;
        width: 100%;
      }

      /* ==================== CHANNEL SELECTOR ==================== */
      .channel-selector {
        display: flex;
        justify-content: center;
        gap: 1rem;
        margin-bottom: 2rem;
        flex-wrap: wrap;
      }

      .channel-info {
        text-align: center;
        margin-bottom: 1.5rem;
        color: var(--text-light);
      }

      /* ==================== MAP CARDS ==================== */
      .maps-list {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        min-height: 100px;
      }

      .map-card {
        background: var(--surface-color);
        border-radius: 12px;
        padding: 1rem;
        display: flex;
        align-items: center;
        gap: 1rem;
        box-shadow: var(--shadow-sm);
        border: 1px solid #eee;
        transition:
          box-shadow 0.2s,
          transform 0.2s;
        position: relative;
      }

      .map-card:hover {
        box-shadow: var(--shadow-md);
      }

      .drag-handle {
        cursor: grab;
        font-size: 1.25rem;
        color: var(--text-light);
        padding: 0.5rem;
        user-select: none;
      }

      .drag-handle:active {
        cursor: grabbing;
      }

      .map-card-content {
        flex: 1;
        min-width: 0;
      }

      .map-card-content h3 {
        font-size: 1rem;
        font-weight: 700;
        color: var(--text-color);
        margin-bottom: 0.25rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .map-card-content .links {
        font-size: 0.8rem;
        color: var(--text-light);
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .map-card-content .links a {
        color: var(--primary-color);
        text-decoration: none;
      }

      .map-card-content .links a:hover {
        text-decoration: underline;
      }

      .delete-btn {
        position: absolute;
        top: -8px;
        right: -8px;
        width: 28px;
        height: 28px;
        border-radius: 50%;
        background: #dc3545;
        color: white;
        border: 2px solid white;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s;
        box-shadow: var(--shadow-sm);
      }

      .delete-btn:hover {
        transform: scale(1.1);
        background: #c82333;
      }

      /* Drag and Drop States */
      .map-card.sortable-ghost {
        opacity: 0.4;
        background: var(--primary-light);
      }

      .map-card.sortable-chosen {
        box-shadow: 0 8px 24px rgba(136, 192, 166, 0.4);
        transform: scale(1.02);
      }

      /* ==================== MODAL ==================== */
      .modal-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 1rem;
      }

      .modal {
        background: var(--surface-color);
        border-radius: 16px;
        padding: 2rem;
        width: 100%;
        max-width: 480px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      .modal h2 {
        font-family: "Quicksand", sans-serif;
        color: var(--primary-dark);
        margin-bottom: 1.5rem;
        text-align: center;
      }

      .modal-actions {
        display: flex;
        gap: 1rem;
        margin-top: 1.5rem;
      }

      .modal-actions .btn {
        flex: 1;
      }

      /* ==================== SAVE BAR ==================== */
      .save-bar {
        position: sticky;
        bottom: 0;
        background: var(--surface-color);
        padding: 1rem 2rem;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
      }

      /* ==================== RESPONSIVE ==================== */
      @media (max-width: 600px) {
        .dashboard-header {
          flex-direction: column;
          gap: 1rem;
          text-align: center;
        }

        .header-actions {
          width: 100%;
          justify-content: center;
        }

        .map-card {
          flex-direction: column;
          align-items: flex-start;
        }

        .drag-handle {
          align-self: center;
        }
      }
      /* YouTuber Badge Style */
      .youtuber-badge {
        display: inline-flex;
        align-items: center;
        background-color: #e0e0e0; /* Grey box */
        padding: 2px 10px;
        border-radius: 12px;
        color: #333333; /* Dark text for contrast */
        font-weight: 700;
        font-size: 0.9em;
        margin: 0 4px;
        text-decoration: none;
        transition:
          transform 0.2s ease,
          box-shadow 0.2s ease;
        border: 1px solid #ccc;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
      }

      .youtuber-badge:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .youtuber-badge img {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-left: 6px;
        object-fit: cover;
      }

      .youtuber-badge span {
        margin-right: 2px;
      }

      .missing-article-badge {
        background-color: #ffebee;
        color: #c62828;
        border: 1px solid #ef9a9a;
        border-radius: 4px;
        padding: 2px 6px;
        font-size: 0.75rem;
        font-weight: 700;
        display: inline-flex;
        align-items: center;
        margin-left: 0.5rem;
        cursor: help;
      }

      /* Dark Mode Overrides */
      [data-theme="dark"] .status-message.loading {
        background-color: rgba(136, 192, 166, 0.05);
        border-color: #2d3b36;
      }

      [data-theme="dark"] .status-message.error {
        background-color: rgba(220, 53, 69, 0.1);
        color: #ff6b6b;
        border-color: rgba(220, 53, 69, 0.4);
      }

      [data-theme="dark"] .map-card {
        border-color: var(--border-color);
      }

      [data-theme="dark"] .missing-article-badge {
        background-color: #3a1c1c;
        border-color: #5c2b2b;
        color: #ff9999;
      }

      [data-theme="dark"] .youtuber-badge {
        background-color: #333;
        border-color: #444;
        color: #ddd;
      }

      /* ==================== PAGE VIEWS BADGE ==================== */
      .page-views-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
        color: #2e7d32;
        padding: 0.25rem 0.6rem;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 700;
        white-space: nowrap;
        margin-right: auto;
      }

      .page-views-badge.loading {
        background: #f5f5f5;
        color: #999;
      }

      [data-theme="dark"] .page-views-badge {
        background: linear-gradient(135deg, #1b4332 0%, #2d6a4f 100%);
        color: #95d5b2;
      }

      [data-theme="dark"] .page-views-badge.loading {
        background: #333;
        color: #666;
      }

      /* ==================== AI GENERATION PROGRESS ==================== */
      .ai-progress-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.95);
        z-index: 10;
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-radius: 10px;
        padding: 2rem;
      }

      [data-theme="dark"] .ai-progress-overlay {
        background: rgba(30, 30, 30, 0.95);
      }

      .ai-progress-overlay.show {
        display: flex;
      }

      .progress-steps {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        width: 100%;
        max-width: 300px;
      }

      .progress-step {
        display: flex;
        align-items: center;
        gap: 1rem;
        opacity: 0.5;
        transition: all 0.3s ease;
      }

      .progress-step.active {
        opacity: 1;
        transform: scale(1.02);
      }

      .progress-step.completed {
        opacity: 0.8;
      }

      .step-icon {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        background: var(--surface-color);
        border: 2px solid var(--text-light);
        color: var(--text-light);
        font-size: 0.8rem;
        transition: all 0.3s ease;
      }

      .progress-step.active .step-icon {
        border-color: var(--primary-color);
        color: var(--primary-color);
        animation: pulse 1.5s infinite;
      }

      .progress-step.completed .step-icon {
        background: var(--primary-color);
        border-color: var(--primary-color);
        color: white;
      }

      .step-label {
        font-weight: 600;
        color: var(--text-color);
      }

      @keyframes pulse {
        100% { box-shadow: 0 0 0 0 rgba(136, 192, 166, 0); }
      }

      /* Video Preview Styles */
      .video-preview {
        width: 120px;
        height: 68px;
        flex-shrink: 0;
        position: relative;
        border-radius: 8px;
        overflow: hidden;
        background: #000;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .video-preview img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        opacity: 0.9;
        transition: opacity 0.2s;
      }

      .video-preview:hover img {
        opacity: 0.7;
      }



      .video-preview-placeholder {
        width: 120px;
        height: 68px;
        flex-shrink: 0;
        background: #eee;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
        border-radius: 8px;
        font-size: 0.8rem;
      }

      [data-theme="dark"] .video-preview-placeholder {
        background: #333;
        color: #666;
      }
    </style>
    <script>
      function initTheme() {
        const saved = localStorage.getItem("theme");
        if (saved) {
          document.documentElement.setAttribute("data-theme", saved);
        } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
          document.documentElement.setAttribute("data-theme", "dark");
        }
      }
      initTheme();

      function toggleTheme() {
        const current = document.documentElement.getAttribute("data-theme");
        const target = current === "dark" ? "light" : "dark";
        document.documentElement.setAttribute("data-theme", target);
        localStorage.setItem("theme", target);
        updateThemeIcons(target);
      }

      function updateThemeIcons(theme) {
        // We will add class 'theme-icon' to the icons
        const icons = document.querySelectorAll(".theme-icon");
        icons.forEach((icon) => {
          icon.className =
            theme === "dark"
              ? "fas fa-sun theme-icon"
              : "fas fa-moon theme-icon";
        });
      }

      document.addEventListener("DOMContentLoaded", () => {
        const current =
          document.documentElement.getAttribute("data-theme") || "light";
        updateThemeIcons(current);
      });
    </script>
  </head>
  <body>
    <!-- ==================== LOGIN VIEW ==================== -->
    <div id="login-view">
      <div class="login-card" style="position: relative">
        <button
          onclick="toggleTheme()"
          class="btn btn-secondary"
          style="
            position: absolute;
            top: 1rem;
            right: 1rem;
            padding: 0.5rem;
            border: none;
            background: transparent;
            color: var(--text-color);
          "
        >
          <i class="fas fa-moon theme-icon"></i>
        </button>
        <div class="login-header">
          <div class="logo">ğŸ” Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</div>
          <p>Ø¯Ø®ÙˆÙ„ Ù…ØµØ±Ø­ ÙÙ‚Ø·</p>
        </div>
        <form id="login-form">
          <div class="form-group">
            <label for="email">Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ</label>
            <input
              type="email"
              id="email"
              required
              placeholder="admin@example.com"
              autocomplete="email"
            />
          </div>
          <div class="form-group">
            <label for="password">ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</label>
            <input
              type="password"
              id="password"
              required
              placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±"
              autocomplete="current-password"
            />
          </div>
          <button type="submit" class="btn btn-full" id="login-btn">
            ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
          </button>
        </form>
        <div id="login-status" class="status-message"></div>
      </div>
    </div>

    <!-- ==================== DASHBOARD VIEW ==================== -->
    <div id="dashboard-view" class="hidden">
      <header class="dashboard-header">
        <h1>ğŸ® Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ù…Ø­ØªÙˆÙ‰</h1>
        <div class="header-actions">
          <button
            onclick="toggleTheme()"
            class="btn btn-secondary"
            style="padding: 0.5rem 1rem"
          >
            <i class="fas fa-moon theme-icon"></i>
          </button>
          <button id="add-item-btn" class="btn">â• Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ±</button>
          <button id="logout-btn" class="btn btn-secondary">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬</button>
        </div>
      </header>

      <main class="dashboard-content">
        <!-- Status -->
        <div id="loading-indicator" class="status-message show loading">
          Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰...
        </div>

        <!-- Channel Selector Buttons -->
        <div id="channel-buttons" class="channel-selector"></div>

        <!-- Channel Info -->
        <div id="channel-info" class="channel-info"></div>

        <!-- Maps List for Current Channel -->
        <div id="maps-list" class="maps-list"></div>
      </main>

      <footer class="save-bar">
        <button id="save-btn" class="btn" disabled>ğŸ’¾ Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª</button>
        <div
          id="save-status"
          class="status-message"
          style="margin: 0; padding: 0.5rem 1rem"
        ></div>
      </footer>
    </div>

    <!-- ==================== ADD ITEM MODAL ==================== -->
    <div id="add-modal" class="modal-overlay hidden">
      <div class="modal">
        <h2>â• Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ± Ø¬Ø¯ÙŠØ¯</h2>
        <form id="add-form">
          <!-- Map Name Removed -->
          <div class="form-group">
            <label for="add-video-link">Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ</label>
            <input
              type="url"
              id="add-video-link"
              required
              placeholder="https://youtu.be/..."
            />
          </div>
          <div class="form-group">
            <label for="add-map-link">Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ø§Ø¨ (Ø±ÙˆØ¨Ù„ÙˆÙƒØ³)</label>
            <input
              type="url"
              id="add-map-link"
              required
              placeholder="https://www.roblox.com/games/..."
            />
          </div>
          <div class="form-group">
            <label for="add-article-content">
              Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù‚Ø§Ù„ (Markdown)
              <button
                type="button"
                id="generate-article-btn"
                class="btn"
                style="
                  margin-right: 10px;
                  font-size: 0.8em;
                  padding: 4px 12px;
                  background-color: #7b1fa2;
                "
              >
                âœ¨ ÙƒØªØ§Ø¨Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
              </button>
            </label>
            <div style="position: relative;">
                <textarea id="add-article-content"></textarea>
                <!-- Progress Overlay -->
                <div id="ai-progress" class="ai-progress-overlay">
                    <h3 style="margin-bottom: 1.5rem; color: var(--primary-dark);">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡...</h3>
                    <div id="realtime-logs" style="
                        width: 100%;
                        max-width: 400px;
                        max-height: 250px;
                        overflow-y: auto;
                        background: rgba(0,0,0,0.05);
                        border-radius: 8px;
                        padding: 1rem;
                        font-family: monospace;
                        font-size: 0.9rem;
                    ">
                        <div class="log-entry" style="color: var(--text-color); margin-bottom: 0.5rem; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 0.5rem;">
                            <i class="fas fa-satellite-dish"></i> Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...
                        </div>
                    </div>
                    <p id="progress-timer" style="margin-top: 1.5rem; color: var(--text-light); font-size: 0.9rem; font-family: monospace;">00:00</p>
                    <button id="ai-progress-close-btn" class="btn" style="margin-top: 1rem; display: none;">Ø¥ØºÙ„Ø§Ù‚</button>
                </div>
            </div>
          </div>
          <div class="modal-actions">
            <button type="button" id="cancel-add-btn" class="btn btn-secondary">
              Ø¥Ù„ØºØ§Ø¡
            </button>
            <button type="submit" class="btn">Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù†ØµØ±</button>
          </div>
        </form>
      </div>
    </div>

    <script src="../scripts/title-utils.js"></script>
    <!-- Firebase SDK -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
      import {
        getAuth,
        signInWithEmailAndPassword,
        signOut,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        getDoc,
        setDoc,
        onSnapshot,
        enableNetwork,
        waitForPendingWrites,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
      import {
        getFunctions,
        httpsCallable,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js";

      // Import Config
      import { firebaseConfig } from "../config/firebase-config.js";

      // Initialize Firebase
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);
      const functions = getFunctions(app);

      // ==================== STATE ====================
      let allChannelsData = {}; // All channels: { "channelName": [...maps], ... }
      let channelOrder = []; // Preserves original channel order
      let currentChannel = null;
      let hasChanges = false;
      let sortableInstance = null;
      let editingItemCard = null; // Track which card is being edited (null = adding new)
      let pageViewsData = {}; // Raw analytics: { "/path": 1234 }
      let preprocessedViews = {}; // Final mapping: { "videoId": 5678 }

      // ==================== DOM ELEMENTS ====================
      const loginView = document.getElementById("login-view");
      const dashboardView = document.getElementById("dashboard-view");
      const loginForm = document.getElementById("login-form");
      const loginBtn = document.getElementById("login-btn");
      const logoutBtn = document.getElementById("logout-btn");
      const loginStatus = document.getElementById("login-status");
      const loadingIndicator = document.getElementById("loading-indicator");
      const channelButtonsContainer =
        document.getElementById("channel-buttons");
      const channelInfo = document.getElementById("channel-info");
      const mapsList = document.getElementById("maps-list");
      const addItemBtn = document.getElementById("add-item-btn");
      const addModal = document.getElementById("add-modal");
      const addForm = document.getElementById("add-form");
      const cancelAddBtn = document.getElementById("cancel-add-btn");
      const saveBtn = document.getElementById("save-btn");
      const saveStatus = document.getElementById("save-status");

      // ==================== FIRESTORE INITIALIZATION ====================
      // Ensure Firestore connection is ready before attempting to load data
      async function ensureFirestoreReady() {
        try {
          // Explicitly enable network (in case it was disabled)
          await enableNetwork(db);
          
          // Wait for any pending writes to complete
          await waitForPendingWrites(db);
          
          // Add a small buffer to let WebChannel connection establish
          await new Promise((resolve) => setTimeout(resolve, 500));
        } catch (error) {
          console.warn("Error during Firestore initialization:", error);
          // Don't throw - let the retry logic in getDocWithRetry handle it
        }
      }

      // ==================== AUTH STATE ====================
      onAuthStateChanged(auth, async (user) => {
        if (user) {
          loginView.classList.add("hidden");
          dashboardView.classList.remove("hidden");
          
          // Wait for Firestore to be ready before loading
          await ensureFirestoreReady();
          await loadContent();
          // Load analytics in background (non-blocking)
          loadPageViews();
        } else {
          loginView.classList.remove("hidden");
          dashboardView.classList.add("hidden");
        }
      });

      // ==================== LOGIN ====================
      loginForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const email = document.getElementById("email").value;
        const password = document.getElementById("password").value;

        loginBtn.disabled = true;
        loginBtn.textContent = "Ø¬Ø§Ø±ÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„...";
        showStatus(loginStatus, "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©...", "loading");

        try {
          await signInWithEmailAndPassword(auth, email, password);
        } catch (error) {
          showStatus(loginStatus, getErrorMessage(error.code), "error");
        } finally {
          loginBtn.disabled = false;
          loginBtn.textContent = "ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„";
        }
      });

      // ==================== LOGOUT ====================
      logoutBtn.addEventListener("click", async () => {
        if (
          hasChanges &&
          !confirm(
            "Ù„Ø¯ÙŠÙƒ ØªØºÙŠÙŠØ±Ø§Øª Ù„Ù… ÙŠØªÙ… Ø­ÙØ¸Ù‡Ø§. Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ ØªØ±ÙŠØ¯ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬ØŸ",
          )
        ) {
          return;
        }
        await signOut(auth);
      });

      // ==================== HELPER: RETRY LOGIC ====================
      async function getDocWithRetry(docRef, retries = 3, delay = 2000) {
        try {
          return await getDoc(docRef);
        } catch (error) {
          // Check for offline/connection errors
          const isOffline =
            error.message.includes("offline") ||
            error.code === "unavailable" ||
            error.message.includes("network") ||
            error.message.includes("failed-precondition");

          if (retries > 0 && isOffline) {
            console.warn(
              `Firestore getDoc failed (${error.code || error.message}). Retrying in ${delay}ms... (${retries} attempts remaining)`,
            );

            // Optional: Update loading text
            if (
              loadingIndicator &&
              !loadingIndicator.classList.contains("hidden")
            ) {
              loadingIndicator.textContent = `Connection issue detected. Retrying... (${retries} attempts left)`;
            }

            await new Promise((resolve) => setTimeout(resolve, delay));
            return getDocWithRetry(docRef, retries - 1, delay * 1.5); // Exponential backoff
          }
          throw error;
        }
      }

      // ==================== LOAD CONTENT ====================
      async function loadContent() {
        loadingIndicator.classList.remove("hidden");
        loadingIndicator.textContent = "Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰...";

        try {
          // Try Firestore first
          const docRef = doc(db, "content", "main");
          const docSnap = await getDocWithRetry(docRef);

          if (docSnap.exists() && docSnap.data().maps) {
            const data = docSnap.data();
            allChannelsData = data.maps;
            // Sort channels by list_number
            channelOrder = Object.keys(allChannelsData).sort((a, b) => {
              return (allChannelsData[a].list_number ?? 999) - (allChannelsData[b].list_number ?? 999);
            });
          } else {
            // Fallback: Load from local links.json
            loadingIndicator.textContent = "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ù…Ù† JSON Ø§Ù„Ù…Ø­Ù„ÙŠ...";
            const response = await fetch(
              "../config/links.json?t=" + new Date().getTime(),
            );
            if (!response.ok) throw new Error("ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ links.json");
            allChannelsData = await response.json();
            // Sort channels by list_number
            channelOrder = Object.keys(allChannelsData).sort((a, b) => {
              return (allChannelsData[a].list_number ?? 999) - (allChannelsData[b].list_number ?? 999);
            });
          }

          // Render channel buttons
          renderChannelButtons();

          // Select first channel by default
          if (channelOrder.length > 0) {
            switchChannel(channelOrder[0]);
          }

          loadingIndicator.classList.add("hidden");
        } catch (error) {
          console.error("Error loading content:", error);
          loadingIndicator.textContent =
            "Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰: " + error.message;
          loadingIndicator.className = "status-message show error";
        }
      }

      // ==================== LOAD PAGE VIEWS ====================
      async function loadPageViews() {
        try {
          const getPageViews = httpsCallable(functions, "getPageViews");
          const result = await getPageViews();
          
          if (result.data.success) {
            pageViewsData = result.data.pageViews;
            
            // Pre-process raw paths into videoId->totalViews map (O(M))
            preprocessedViews = {};
            for (const [path, views] of Object.entries(pageViewsData)) {
              const urlParams = new URLSearchParams(path.split('?')[1] || '');
              const videoId = urlParams.get('v') || urlParams.get('id');
              
              if (videoId) {
                preprocessedViews[videoId] = (preprocessedViews[videoId] || 0) + views;
              } else {
                // Fallback for weird paths or different param names
                const match = path.match(/[?&](?:v|id)=([^&]+)/i);
                if (match) {
                  const vId = match[1];
                  preprocessedViews[vId] = (preprocessedViews[vId] || 0) + views;
                }
              }
            }
            
            updateAllPageViewBadges();
          }
        } catch (error) {
          console.warn("Could not load page views:", error.message);
          // Silently fail - analytics is optional
          document.querySelectorAll(".page-views-badge").forEach(badge => {
            badge.textContent = "ğŸ‘ï¸ â€”";
            badge.classList.remove("loading");
          });
        }
      }

      function updateAllPageViewBadges() {
        requestAnimationFrame(() => {
          document.querySelectorAll(".page-views-badge").forEach(badge => {
            const videoId = badge.dataset.videoId;
            if (videoId) {
              const totalViews = preprocessedViews[videoId] || 0;
              
              badge.textContent = `ğŸ‘ï¸ ${formatNumber(totalViews)}`;
              badge.classList.remove("loading");
              badge.title = `${totalViews.toLocaleString()} Ù…Ø´Ø§Ù‡Ø¯Ø© (Ø¢Ø®Ø± 30 ÙŠÙˆÙ…)`;
            }
          });
        });
      }

      function formatNumber(num) {
        if (num >= 1000000) {
          return (num / 1000000).toFixed(1) + "M";
        } else if (num >= 1000) {
          return (num / 1000).toFixed(1) + "K";
        }
        return num.toString();
      }

      // ==================== RENDER CHANNEL BUTTONS ====================
      function renderChannelButtons() {
        channelButtonsContainer.innerHTML = "";

        // Use channelOrder to ensure consistent button order
        channelOrder.forEach((channelName) => {
          if (allChannelsData[channelName]) {
            const btn = document.createElement("button");
            btn.className = "btn channel-btn";
            btn.textContent = channelName;
            btn.dataset.channel = channelName;
            btn.onclick = () => switchChannel(channelName);
            channelButtonsContainer.appendChild(btn);
          }
        });
      }

      // ==================== TEXT DIRECTION HELPER ====================
      function setElementDirection(element, text) {
        const arabicPattern =
          /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
        if (arabicPattern.test(text)) {
          element.style.direction = "rtl";
          element.style.textAlign = "right";
        } else {
          element.style.direction = "ltr";
          element.style.textAlign = "left";
        }
      }

      function updateChannelButtonStyles() {
        const buttons =
          channelButtonsContainer.querySelectorAll(".channel-btn");
        buttons.forEach((btn) => {
          if (btn.dataset.channel === currentChannel) {
            btn.classList.add("active");
          } else {
            btn.classList.remove("active");
          }
        });
      }

      function normalizeYoutubeLink(url) {
        return TitleUtils.normalizeYoutubeLink(url);
      }

      // ==================== SWITCH CHANNEL ====================
      function switchChannel(channelName) {
        currentChannel = channelName;
        updateChannelButtonStyles();
        renderMapsList();
      }

      function formatTitleWithBadges(title) {
        return TitleUtils.formatTitleWithBadges(title);
      }

      async function processBadges(container) {
        return TitleUtils.processBadges(container);
      }

      function updateBadgeUI(badge, name, avatar, url) {
        return TitleUtils.updateBadgeUI(badge, name, avatar, url);
      }

      async function fetchVideoTitle(videoUrl) {
        return TitleUtils.fetchVideoTitle(videoUrl);
      }

      // ==================== RENDER MAPS LIST ====================
      function renderMapsList() {
        mapsList.innerHTML = "";

        // Access the links array from the new structure
        const channelData = allChannelsData[currentChannel];
        const maps = channelData?.links || channelData || [];
        channelInfo.textContent = `${currentChannel} â€” ${maps.length} Ø¹Ù†ØµØ±`;

        if (maps.length === 0) {
          mapsList.innerHTML =
            '<p style="text-align: center; color: var(--text-light); padding: 2rem;">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¹Ù†Ø§ØµØ± ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ù†Ø§Ø©. Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ "Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ±" Ù„Ø¥Ù†Ø´Ø§Ø¡ ÙˆØ§Ø­Ø¯.</p>';
          return;
        }

        maps.forEach((map, index) => {
          mapsList.appendChild(createMapCard(map, index));
        });

        // Initialize SortableJS
        if (sortableInstance) {
          sortableInstance.destroy();
        }
        sortableInstance = new Sortable(mapsList, {
          animation: 150,
          ghostClass: "sortable-ghost",
          chosenClass: "sortable-chosen",
          handle: ".drag-handle",
          onEnd: () => {
            updateDataFromDOM();
            markChanged();
          },
        });
      }

      function createMapCard(map, index) {
        const card = document.createElement("div");
        card.className = "map-card";
        card.dataset.index = index;

        // Video Thumbnail Logic
        const videoId = extractVideoId(map.video_link);
        const thumbnailUrl = videoId
          ? `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`
          : "";

        let thumbnailHtml = "";
        if (videoId) {
          thumbnailHtml = `
            <div class="video-preview" data-video-id="${videoId}" title="Click to play">
                <img src="${thumbnailUrl}" alt="Thumbnail">
            </div>`;
        } else {
          thumbnailHtml = `<div class="video-preview-placeholder"><i class="fas fa-video-slash"></i></div>`;
        }

        card.innerHTML = `
                <div class="drag-handle">â˜°</div>
                ${thumbnailHtml}
                <div class="map-card-content">
                    <h3 class="editable-title" title="Ø§Ù†Ù‚Ø± Ù„Ù„ØªØ¹Ø¯ÙŠÙ„">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†...</h3>
                    <div class="links">
                        <a href="${escapeHtml(map.map_link)}" target="_blank" class="btn btn-secondary" style="font-size: 0.8rem; padding: 0.25rem 0.75rem; border-radius: 6px;">ğŸ® Roblox</a>
                        <a href="../article/?id=${videoId}" target="_blank" class="btn btn-secondary" style="font-size: 0.8rem; padding: 0.25rem 0.75rem; border-radius: 6px;">ğŸ“„ Article</a>
                    </div>
                </div>
                <span class="page-views-badge loading" data-video-id="">ğŸ‘ï¸ ...</span>
                <button class="delete-btn" title="Ø­Ø°Ù">âœ•</button>
            `;

        // Store full data on the card for retrieval
        card.dataset.mapData = JSON.stringify(map);

        // Video Preview Click Handler
        if (videoId) {
          const preview = card.querySelector(".video-preview");
          preview.addEventListener("click", (e) => {
            e.stopPropagation(); // prevent card click or other bubbling
            window.open(`https://www.youtube.com/watch?v=${videoId}`, '_blank');
          });
        }

        // Set video ID on the page views badge
        if (videoId) {
          const badge = card.querySelector(".page-views-badge");
          badge.dataset.videoId = videoId;
          // If analytics already loaded, update this badge immediately
          if (Object.keys(preprocessedViews).length > 0) {
            const views = preprocessedViews[videoId] || 0;
            badge.textContent = `ğŸ‘ï¸ ${formatNumber(views)}`;
            badge.classList.remove("loading");
            badge.title = `${views.toLocaleString()} Ù…Ø´Ø§Ù‡Ø¯Ø© (Ø¢Ø®Ø± 30 ÙŠÙˆÙ…)`;
          }
        }

        // Fetch Title
        fetchVideoTitle(map.video_link).then((title) => {
          const titleEl = card.querySelector("h3");
          const displayTitle = title || "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...";

          // Apply RTL if Arabic found
          setElementDirection(titleEl, displayTitle);

          titleEl.innerHTML = formatTitleWithBadges(displayTitle);
          processBadges(titleEl);
        });

        // Check if article exists
        if (videoId) {
          // Check if map object already has content (from DOM update)
          if (!map.article_content) {
            checkArticleExists(videoId).then((exists) => {
              if (!exists) {
                const linksContainer = card.querySelector(".links");
                const badge = document.createElement("span");
                badge.className = "missing-article-badge";
                badge.textContent = "âš ï¸ Ø§Ù„Ù…Ù‚Ø§Ù„ Ù…ÙÙ‚ÙˆØ¯!";
                badge.title = "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„Ù Markdown Ù„Ù‡Ø°Ø§ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ.";
                linksContainer.appendChild(badge);
              }
            });
          }
        }

        // Edit handler (Click on content area, ignore links/buttons)
        card
          .querySelector(".map-card-content")
          .addEventListener("click", (e) => {
            if (e.target.tagName === "A") return;
            openEditModal(card, map);
          });

        // Delete handler
        card.querySelector(".delete-btn").addEventListener("click", (e) => {
          e.stopPropagation();
          if (confirm("Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ø£Ù†Ùƒ ØªØ±ÙŠØ¯ Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ø¹Ù†ØµØ±ØŸ")) {
            card.remove();
            updateDataFromDOM();
            markChanged();
            const count = mapsList.querySelectorAll(".map-card").length;
            channelInfo.textContent = `${currentChannel} â€” ${count} Ø¹Ù†ØµØ±`;
          }
        });

        return card;
      }

      // ==================== ADD / EDIT ITEM ====================
      function openEditModal(card, mapData) {
        editingItemCard = card;

        // Update Modal Title
        addModal.querySelector("h2").textContent = card
          ? "âœ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø¹Ù†ØµØ±"
          : "â• Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ±";
        addModal.querySelector('button[type="submit"]').textContent = card
          ? "Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª"
          : "Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ±";

        // Fill form
        if (mapData) {
          document.getElementById("add-video-link").value =
            mapData.video_link || "";
          document.getElementById("add-map-link").value =
            mapData.map_link || "";
        } else {
          addForm.reset();
        }

        addModal.classList.remove("hidden");

        // Populate textarea: try existing data first, then fetch file
        const textarea = document.getElementById("add-article-content");
        textarea.value = mapData ? mapData.article_content || "" : "";
        textarea.placeholder = "Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù‚Ø§Ù„ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯...";

        if (mapData && mapData.video_link && !textarea.value) {
          const videoId = extractVideoId(mapData.video_link);
          if (videoId) {
            fetch(`../assets/articles/${videoId}.md?t=${new Date().getTime()}`)
              .then((response) => {
                if (response.ok) return response.text();
                throw new Error("Not found");
              })
              .then((text) => {
                // Only update if user hasn't started typing
                if (textarea.value === "") {
                  textarea.value = text;
                }
              })
              .catch((err) => {
                textarea.placeholder =
                  "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù‚Ø§Ù„. Ø§ÙƒØªØ¨ ÙˆØ§Ø­Ø¯Ø§Ù‹ Ù‡Ù†Ø§...";
              });
          }
        } else if (!mapData) {
          textarea.placeholder = "Ø§ÙƒØªØ¨ Ù…Ù‚Ø§Ù„Ùƒ Ù‡Ù†Ø§...";
        }
      }

      function extractVideoId(url) {
        return TitleUtils.getVideoId(url);
      }

      addItemBtn.addEventListener("click", () => {
        openEditModal(null, null);
      });

      cancelAddBtn.addEventListener("click", () => {
        addModal.classList.add("hidden");
      });

      /*
        addModal.addEventListener('click', (e) => {
            if (e.target === addModal) {
                addModal.classList.add('hidden');
            }
        });
        */

      addForm.addEventListener("submit", (e) => {
        e.preventDefault();

        let videoLink = document.getElementById("add-video-link").value;
        videoLink = normalizeYoutubeLink(videoLink);

        const mapLink = document.getElementById("add-map-link").value;

        const newMap = {
          video_link: videoLink,
          map_link: mapLink,
          article_content: document.getElementById("add-article-content").value,
        };

        if (editingItemCard) {
          // EDIT MODE: Update existing card
          const newCard = createMapCard(newMap, 0); // index doesn't matter here
          mapsList.replaceChild(newCard, editingItemCard);
        } else {
          // ADD MODE: Add to beginning
          const newCard = createMapCard(newMap, 0);
          mapsList.prepend(newCard);
        }

        updateDataFromDOM();
        markChanged();

        // Update channel info count
        const count = mapsList.querySelectorAll(".map-card").length;
        channelInfo.textContent = `${currentChannel} â€” ${count} Ø¹Ù†ØµØ±`;

        addModal.classList.add("hidden");
      });

      // ==================== SAVE CHANGES ====================
      saveBtn.addEventListener("click", async () => {
        // Re-verify auth
        const user = auth.currentUser;
        if (!user) {
          showStatus(
            saveStatus,
            "Ù„Ù… ØªØªÙ… Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.",
            "error",
          );
          return;
        }

        saveBtn.disabled = true;
        saveBtn.textContent = "â³ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸...";
        showStatus(saveStatus, "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸ ÙÙŠ Firestore...", "loading");

        try {
          // Get existing Firestore data or create new
          const docRef = doc(db, "content", "main");
          const docSnap = await getDoc(docRef);
          let fullData = docSnap.exists() ? docSnap.data() : {};

          // Update maps and channel order
          // Update maps
          fullData.maps = allChannelsData;
          // fullData.channelOrder = channelOrder; // Removed to fix ordering issues

          // Save to Firestore
          await setDoc(docRef, fullData);

          showStatus(saveStatus, "Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆÙ‚Ø¹...", "loading");

          // Trigger GitHub Action
          await triggerGitHubAction();

          showStatus(saveStatus, "âœ… ØªÙ… Ø§Ù„Ø­ÙØ¸ ÙˆØ§Ù„Ù†Ø´Ø±!", "success");
          hasChanges = false;
          saveBtn.disabled = true;
        } catch (error) {
          console.error("Save error:", error);
          showStatus(saveStatus, "Ø®Ø·Ø£: " + error.message, "error");
        } finally {
          saveBtn.textContent = "ğŸ’¾ Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª";
        }
      });

      async function checkArticleExists(videoId) {
        try {
          // Use HEAD request to check availability efficiently
          const response = await fetch(`../assets/articles/${videoId}.md`, {
            method: "HEAD",
          });
          return response.ok;
        } catch (e) {
          return false;
        }
      }

      async function triggerGitHubAction() {
        try {
          const triggerAction = httpsCallable(functions, "triggerGitHubAction");
          const result = await triggerAction();
          console.log("GitHub Action triggered successfully:", result.data);
        } catch (error) {
          console.error("Error triggering GitHub Action:", error);
          throw new Error("Failed to trigger build: " + error.message);
        }
      }

      // ==================== AI GENERATION ====================
      const generateArticleBtn = document.getElementById(
        "generate-article-btn",
      );
      const aiProgress = document.getElementById("ai-progress");
      const progressTimer = document.getElementById("progress-timer");
      const realtimeLogs = document.getElementById("realtime-logs");

      const aiProgressCloseBtn = document.getElementById("ai-progress-close-btn");

      // Close button handler
      aiProgressCloseBtn.addEventListener("click", () => {
          aiProgress.classList.remove('show');
          generateArticleBtn.disabled = false;
          generateArticleBtn.innerHTML = generateArticleBtn.dataset.originalText || "âœ¨ ÙƒØªØ§Ø¨Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ"; // Fallback text
      });

      // Generate UUID helper
      function uuidv4() {
          return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, c =>
            (+c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)
          );
      }

      generateArticleBtn.addEventListener("click", async () => {
        const videoUrl = document.getElementById("add-video-link").value;
        const textarea = document.getElementById("add-article-content");

        if (!videoUrl) {
          alert("Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø£ÙˆÙ„Ø§Ù‹.");
          return;
        }

        if (
          textarea.value &&
          !confirm(
            "Ø³ÙŠØ¤Ø¯ÙŠ Ù‡Ø°Ø§ Ø¥Ù„Ù‰ Ø§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ. Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©ØŸ",
          )
        ) {
          return;
        }

        const originalText = generateArticleBtn.innerHTML;
        generateArticleBtn.dataset.originalText = originalText; // Store for restore
        generateArticleBtn.disabled = true;
        
        // Setup Real-time Logging
        const requestId = uuidv4();
        aiProgress.classList.add('show');
        aiProgressCloseBtn.style.display = 'none'; // Hide close button initially
        realtimeLogs.innerHTML = `<div class="log-entry" style="color: var(--text-color); margin-bottom: 0.5rem; border-bottom: 1px solid rgba(0,0,0,0.1); padding-bottom: 0.5rem;">
                            <i class="fas fa-satellite-dish"></i> Ø¬Ø§Ø±ÙŠ Ø¨Ø¯Ø¡ Ø§Ù„Ø·Ù„Ø¨...
                        </div>`;

        // Start Timer
        let startTime = Date.now();
        let timerInterval = setInterval(() => {
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const secs = (elapsed % 60).toString().padStart(2, '0');
            progressTimer.textContent = `${mins}:${secs}`;
        }, 1000);

        // Listen to Firestore
        let unsubscribe;
        try {
            console.log("Subscribing to logs for requestId:", requestId);
            unsubscribe = onSnapshot(doc(db, "generation_logs", requestId), (docC) => {
                // console.log("Snapshot update:", docC.exists(), docC.data()); 
                if (docC.exists()) {
                    const data = docC.data();
                    const icon = data.type === 'error' ? 'fa-exclamation-circle' : (data.type === 'success' ? 'fa-check-circle' : 'fa-info-circle');
                    const color = data.type === 'error' ? 'red' : (data.type === 'success' ? 'green' : 'var(--text-color)');
                    
                    const logEntry = document.createElement('div');
                    logEntry.style.color = color;
                    logEntry.style.marginBottom = '0.5rem';
                    logEntry.style.paddingBottom = '0.5rem';
                    logEntry.style.borderBottom = '1px solid rgba(0,0,0,0.1)';
                    logEntry.innerHTML = `<i class="fas ${icon}"></i> ${data.message}`;
                    realtimeLogs.appendChild(logEntry);
                    // Scroll to bottom
                    realtimeLogs.scrollTop = realtimeLogs.scrollHeight;
                }
            }, (error) => {
                console.error("Snapshot listener error:", error);
                const logEntry = document.createElement('div');
                logEntry.style.color = 'red';
                logEntry.innerHTML = `<i class="fas fa-exclamation-triangle"></i> ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø³Ø¬Ù„: ${error.message}`;
                realtimeLogs.appendChild(logEntry);
            });
        } catch (e) {
            console.error("Failed to subscribe to logs:", e);
        }

        let isSuccess = false;

        try {
          const generate = httpsCallable(functions, "generateArticle", {
            timeout: 1200000,
          });
          const result = await generate({ videoUrl: videoUrl, requestId: requestId });

          if (result.data.success && result.data.article) {
            textarea.value = result.data.article;
            markChanged(); // Mark as modified so user can save
            isSuccess = true;
          } else {
            throw new Error("Ù„Ù… ÙŠØªÙ… Ø¥Ø±Ø¬Ø§Ø¹ Ø£ÙŠ Ù…Ù‚Ø§Ù„.");
          }
        } catch (error) {
          console.error("Generation failed:", error);
          // Don't alert, just log to the visible log area
          const logEntry = document.createElement('div');
          logEntry.style.color = 'red';
          logEntry.style.fontWeight = 'bold';
          logEntry.innerHTML = `<i class="fas fa-times-circle"></i> Ø®Ø·Ø£: ${error.message}`;
          realtimeLogs.appendChild(logEntry);
          realtimeLogs.scrollTop = realtimeLogs.scrollHeight;
        } finally {
          clearInterval(timerInterval);
          if (unsubscribe) unsubscribe(); // Stop listening
          
          if (isSuccess) {
              // On success, close automatically
              aiProgress.classList.remove('show');
              generateArticleBtn.disabled = false;
              generateArticleBtn.innerHTML = originalText;
          } else {
              // On failure, keep open and show close button
              aiProgressCloseBtn.style.display = 'inline-block';
              // Button is still disabled until they close the dialog
          }
        }
      });

      async function getGitHubToken() {
        // 1. Check LocalStorage
        let token = localStorage.getItem("github_pat");
        if (token) return token;

        // 2. Prompt User (Securely)
        const input = prompt(
          "Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù…Ø² Ø§Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ø´Ø®ØµÙŠ (PAT) Ø§Ù„Ø®Ø§Øµ Ø¨Ù€ GitHub Ù„Ù†Ø´Ø± Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª.\n\nØ³ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„Ø±Ù…Ø² Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙŠ Ù…ØªØµÙØ­Ùƒ.\nÙŠØ­ØªØ§Ø¬ Ø§Ù„Ø±Ù…Ø² Ø¥Ù„Ù‰ Ø£Ø°ÙˆÙ†Ø§Øª 'actions:write' Ø£Ùˆ 'workflow'.",
        );

        if (input && input.trim().length > 0) {
          token = input.trim();
          localStorage.setItem("github_pat", token);
          return token;
        }

        return null;
      }

      // ==================== UTILITY FUNCTIONS ====================
      function updateDataFromDOM() {
        // Rebuild current channel's data from DOM order
        const newMaps = [];
        mapsList.querySelectorAll(".map-card").forEach((card) => {
          // Retrieve stored data attached to the card - this is the correct source
          const existingData = card.dataset.mapData
            ? JSON.parse(card.dataset.mapData)
            : {};

          newMaps.push({
            video_link: existingData.video_link || "",
            map_link: existingData.map_link || "",
            article_content: existingData.article_content || "",
          });
        });

        // Always preserve the structured format { list_number, links }
        if (allChannelsData[currentChannel] && typeof allChannelsData[currentChannel] === 'object' && !Array.isArray(allChannelsData[currentChannel])) {
          // Channel already has the correct structure, just update links
          allChannelsData[currentChannel].links = newMaps;
        } else {
          // Channel is missing or has wrong structure - create proper structure
          const existingListNumber = allChannelsData[currentChannel]?.list_number ?? Object.keys(allChannelsData).length;
          allChannelsData[currentChannel] = {
            list_number: existingListNumber,
            links: newMaps
          };
        }
      }

      function markChanged() {
        hasChanges = true;
        saveBtn.disabled = false;
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text || "";
        return div.innerHTML;
      }

      function showStatus(element, message, type) {
        element.textContent = message;
        element.className = `status-message show ${type}`;
      }

      function getErrorMessage(errorCode) {
        const messages = {
          "auth/invalid-email": "ØµÙŠØºØ© Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­Ø©.",
          "auth/user-disabled": "ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨.",
          "auth/user-not-found": "Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø­Ø³Ø§Ø¨ Ø¨Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ.",
          "auth/wrong-password": "ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©.",
          "auth/invalid-credential": "Ø¨ÙŠØ§Ù†Ø§Øª ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ ØºÙŠØ± ØµØ§Ù„Ø­Ø©.",
          "auth/too-many-requests": "Ù…Ø­Ø§ÙˆÙ„Ø§Øª ÙØ§Ø´Ù„Ø© ÙƒØ«ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹. Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ø§Ù‹.",
        };
        return messages[errorCode] || "Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹.";
      }

      // Warn before leaving with unsaved changes
      window.addEventListener("beforeunload", (e) => {
        if (hasChanges) {
          e.preventDefault();
          e.returnValue = "";
        }
      });
    </script>
    <script src="../scripts/consent.js"></script>
  </body>
</html>
